#!/usr/bin/env ruby

require 'thor'
require 'csv'
require_relative '../lib/ds/cli'

# TODO: No URIs for Scribes in prototype data set; need test data

class DSConvertCLI < DS::CLI

  def self.exit_on_failure?
    true
  end

  class_option :'output-csv', banner: 'FILE', desc: "Name of the output CSV file [default: output.csv]", default: 'output.csv', aliases: '-o'

  desc "convert MANIFEST SOURCE_DIR", "Generate import CSV for MANIFEST and SOURCE_DIR"
  long_desc <<-LONGDESC
    Generate an import CSV for all files listed in the MANIFEST CSV that are found in SOURCE_DIR.

The MANIFEST is validated before the import CSV is generated. See
'validate' for details.
  LONGDESC
  ##
  # Convert all source records listed in +manifest_csv+; all source
  # records must be in +source_dir+. If +source_dir+ is nil, +convert+
  # expects to find source records in the parent directory of
  # +manifest_csv+.
  #
  # @param [String] manifest_csv path to the DS manifest CSV
  # @param [String] source_dir path to the directory containing all
  #     source records listed in +manifest_csv+
  def convert manifest_csv, source_dir = nil

    invoke :recon_update
    # validate the manifest csv before preceding
    invoke :validate

    # TODO: This is pretty busy; simplify; push to another class?
    manifest  = DS::Manifest::Manifest.new manifest_csv, source_dir
    converter = DS::Converter::Converter.new manifest
    count     = 0
    valid     = true
    outfile   = options[:'output-csv']
    write outfile: outfile do |csv|
      converter.convert do |row|
        count += 1
        csv << row
      end
    end

    print_message(options) { "Wrote #{number_to_delimited(count)} rows to '#{outfile}'" }
    if converter.csv_valid?
      print_message(options) { "CSV is valid: #{outfile}".colorize(:green) }
    else
      raise DSError, "Validation errors found; see previous messages".colorize(:red)
    end
  end

  desc "validate MANIFEST SOURCE_DIR", "Validate the import MANIFEST"
  # Ugh. I can't figure out how to make thor not join consecutive
  # so I've separated each list item.
  long_desc <<LONGDESC
Validate the import MANIFEST and the SOURCE_DIR.

NOTE: Works only for MARC at present.

The validator:

     - Confirms all required columns are present

     - Confirms all all required values are present

     - Confirms all column values are the correct type

     - Confirms all listed input files are present

     - Confirms all listed input files match the record
       identifier provided in the manifest

LONGDESC

  def validate manifest_path, source_dir=nil
    print_message(options, verbose_only: true) {
      "Validating manifest CSV: '#{manifest_path}'"
    }

    manifest = DS::Manifest::Manifest.new manifest_path, source_dir

    manifest_validator = DS::Manifest::ManifestValidator.new manifest
    if manifest_validator.valid?
      print_message(options) {
        "SUCCESS! Manifest is valid: '#{manifest_path}'".colorize(:green)
      }
    else
      print_message(options) { manifest_validator.errors.take(10).join("\n") }
      print_message(options) {
        "ERROR: Manifest has validation errors".colorize(:red)
      }

      exit 1
    end
  end

  protected

  ##
  # Create +outfile+ and yield +csv+ to caller.
  #
  # This method should replace {#write_csv}.
  #
  # @param [String] outfile the outfile name and path
  # @yield [CSV] the CSV object
  def write outfile:, &block
    CSV.open outfile, "w", headers: true do |csv|
      csv << DS::HEADINGS
      yield csv
    end
  end

  def write_csv rows, options
    out_csv = options[:'output-csv']
    CSV.open out_csv, "w", headers: true do |csv|
      csv << DS::HEADINGS
      rows.each do |row|
        csv << row
      end
    end
    puts "Wrote: '#{out_csv}'"
  end

  def validate_args files
    return true if read_from_stdin? files

    cannot_find = files.reject { |f| File.exist?(f) }
    return true if cannot_find.empty?

    puts "Can't find input file(s): #{cannot_find.join '; ' }"
    false
  end
end

DSConvertCLI.start ARGV
